#!/usr/bin/env python
import argparse
from termcolor import colored
import os
import sys
import csv
import numpy
import subprocess
import copy
import glob
import collections
from datetime import datetime, timedelta
import calendar
import re
import colored_traceback.always
import yaml

import tutils

# ----------------------------------------------------------------------------------------
fail_cfg = ['fail-second', 'fail-rep', 'fail-set']
all_grips = set(['half crimp', 'MR', 'MRP', 'thin pinch', 'full crimp', 'IM', 'IMR', 'RP', 'med pinch', 'wide pinch'])
extra_completion_strs = ['completed', 'barely', 'too easy', 'little easy', 'pretty easy']  # phrases i have used at some point that indicate i finished the set (ick)
min_weight_increment = 5  # minimum weight increment between sets/workouts

# ----------------------------------------------------------------------------------------
parser = argparse.ArgumentParser()
parser.add_argument('--mfile', default='%s/Dropbox/hill/m.csv' % os.getenv('HOME'))
parser.add_argument('--years', default='2019:2020:2022:2023:2024:2025') #2018, 2019, 2020])
parser.add_argument('--plot-grips', default='half-crimp:full-crimp:MRP:med-pinch:MR:IM')  # :thin-pinch
parser.add_argument('--training-dir', default=os.getenv('HOME') + '/Dropbox/hill/training')
parser.add_argument('--plotdir', default='%s/hangplots' % os.getenv('HOME'))
parser.add_argument('--debug', action='store_true')
parser.add_argument('--start-date', help='e.g. 2019-Jun-1 (note that the floating average can\'t see any values before this, i.e. the first few days will be only averaged over values on one side (the right)')
parser.add_argument('--stop-date', help='see --start-date')
args = parser.parse_args()

args.years = args.years.split(':')

args.plot_grips = args.plot_grips.replace('-', ' ').split(':')

mfos = tutils.read_mfos(args)

# ----------------------------------------------------------------------------------------
# bash color codes
Colors = {}
Colors['head'] = '\033[95m'
Colors['bold'] = '\033[1m'
Colors['purple'] = '\033[95m'
Colors['blue'] = '\033[94m'
Colors['light_blue'] = '\033[1;34m'
Colors['green'] = '\033[92m'
Colors['yellow'] = '\033[93m'
Colors['red'] = '\033[91m'
Colors['reverse_video'] = '\033[7m'
Colors['red_bkg'] = '\033[41m'
Colors['end'] = '\033[0m'

def color(col, seq, width=None, padside='left'):
    if col is None:
        return seq
    return_str = [Colors[col], seq, Colors['end']]
    if width is not None:  # make sure final string prints to correct width
        n_spaces = max(0, width - len(seq))  # if specified <width> is greater than uncolored length of <seq>, pad with spaces so that when the colors show up properly the colored sequences prints with width <width>
        if padside == 'left':
            return_str.insert(0, n_spaces * ' ')
        elif padside == 'right':
            return_str.insert(len(return_str), n_spaces * ' ')
        else:
            assert False
    return ''.join(return_str)

# ----------------------------------------------------------------------------------------
def read_hfo(hfname, year, n_workouts=None):  # n_workouts: stop after reading this many complete workouts (for testing)
    # ----------------------------------------------------------------------------------------
    def init_workout(line, cfgfo):
        hfo = {}
        lstrs = line.split()
        hfo['session'] = int(lstrs[0].lstrip('>'))
        hfo['date'] = datetime.strptime('%s %s %s' % (lstrs[1].lstrip('('), lstrs[2].rstrip(')').upper(), year), '%d %b %Y')  # for later plotting use
        hfo['grips'] = collections.OrderedDict()
        hfo['cfg'] = copy.deepcopy(cfgfo)
        if len(lstrs) > 3:  # weight, temp, humidity
            extra_lstrs = lstrs[3:]
            for lstr in extra_lstrs:
                if 'F' in lstr:
                    hfo['temp-F'] = int(lstr[:-1])
                elif '%' in lstr:
                    hfo['humid'] = int(lstr[:-1])
                else:  # try to figure out if it's weight... I should've added units
                    hfo['weight'] = float(lstr)
        if args.debug:
            print('  %-s  %2d %s %s' % (color('red' if hfo['session']==1 else 'blue', 'hb %d' % hfo['session'], width=5, padside='right'), hfo['date'].day, color('red_bkg' if hfo['session']==1 else None, calendar.month_abbr[hfo['date'].month]), year))
        return hfo

    # ----------------------------------------------------------------------------------------
    if args.debug:
        print(' reading %s' % hfname)
    cfgfo = None
    workouts = []
    with open(hfname) as hfile:
        hlines = hfile.readlines()
    hfo = None
    iline = -1
    while iline < len(hlines) - 1:
        iline += 1
        line = hlines[iline]
        if line[0] == '#':
            continue

        # if args.debug:
        #     print 'line:', line.strip()

        if line.find('config:') == 0:
            if cfgfo is not None:
                print('    %s cfg info' % color('red', 'replacing'))
            cfgfo = yaml.load(line.lstrip('config: '), Loader=yaml.CLoader)
            assert cfgfo['n_sets'] == len(cfgfo['n_reps'])
            if args.debug:
                print('  config: %s' % cfgfo)
            continue
        elif line[0] == '>':
            hfo = init_workout(line, cfgfo)
            continue
        elif len(line.strip()) == 0:  # empty line: end of workout/after initial config line
            if hfo is not None:  # if it's None, we probably just read the config line
                workouts.append(hfo)
                hfo = None
            if n_workouts is not None and len(workouts) >= n_workouts:
                print('  breaking after %d workouts' % n_workouts)
                break
            continue
        elif line.find('next') == 0:
            if args.debug:
                print('    stopping at \'next:\' block (ignoring %d remaining lines)' % (len(hlines) - iline - 1))
            break

        # actual grip line
        if cfgfo is None:
            raise Exception('didn\'t read config info from %s (line starting with \'config:\')' % hfname)
        lstrs = line.strip().split()
        grip = lstrs.pop(0)
        if grip not in all_grips:
            grip += ' ' + lstrs.pop(0)
        if grip not in all_grips:
            raise Exception('couldn\'t find grip in line \'%s\'' % line)
        gfo = {'grip' : grip, 'sent' : 'no'}
# TODO fix this so you don't miss the >1 first workout if you skipped a grip
        if 'skipped' in lstrs:
            gfo['skipped'] = True
            if args.debug:
                print('     %10s   %s' % (gfo['grip'], color('red', 'skipped')))
            continue
        gfo['added-weights'] = []

        tmpsets = cfgfo['n_sets']
        if 'N_SETS' in line:
            tmpsets = int([l for l in lstrs if 'N_SETS' in l][0].split(':')[1])
        for iset in range(tmpsets):
            if len(lstrs) == 0:
                print('  %s not enough weights in %s at line %d (expected %d sets, got %d -- put a dash for any skipped sets):\n  %s' % (colored('error', 'red'), hfname, iline + 1, tmpsets, iset, line.rstrip()))
                break
            twgt = lstrs.pop(0)
            if twgt == '-':
                gfo['added-weights'].append(numpy.nan)
            else:
                gfo['added-weights'].append(float(twgt))

        if 'N_REPS' in line or 'WORK_TIME' in line or 'REST_TIME' in line:
            raise Exception('not yet implemented')

        if ' '.join(lstrs[0:2]) == 'fail at':
            lstrs = lstrs[2:]
        if len(lstrs) > 0 and lstrs[0] == 'sent':  # new style: make it explicit
            gfo['sent'] = 'yes'
            lstrs.pop(0)
        elif len(lstrs) > 3 and lstrs[1] == 'on' and lstrs[3] == 'of':
            gfo['fail-second'] = int(lstrs[0].rstrip('s'))
            gfo['fail-rep'] = int(lstrs[2])
            gfo['fail-set'] = int(lstrs[4])
            lstrs = lstrs[5:]
        elif len(re.compile('[0-9][0-9][0-9]').findall(''.join(lstrs[:3]))) > 0:  # first three items are three single digit integers
            for tstr in fail_cfg:
                gfo[tstr] = int(lstrs.pop(0))
        elif len(lstrs) == 0:  # old style (less clear)
            gfo['sent'] = 'yes'
        else:
            gfo['sent'] = 'unknown'  # i parse the note below, which can change this
        gfo['note'] = ' '.join(lstrs)

        if gfo['sent'] == 'unknown' and any(e in gfo['note'] for e in extra_completion_strs):
            gfo['sent'] = 'yes'
            if args.debug:
                for estr in [e for e in extra_completion_strs if e in gfo['note']]:
                    gfo['note'] = gfo['note'].replace(estr, color('green', estr))
        if 'NEW_GRIP' in gfo['note']:
            if args.debug:
                print('    %s changed %s grip (see note)' % (color('red', 'note'), gfo['grip']))

        if hfo is None:
            raise Exception('grip line found but no workout initialized in %s at line %d:\n  %s' % (hfname, iline + 1, line.rstrip()))
        hfo['grips'][gfo['grip']] = gfo

        if args.debug:
            if gfo['sent'] == 'unknown':
                sentstr = color('purple', '?')
            elif gfo['sent'] == 'yes':
                sentstr = color('green', 'x')
            else:
                sentstr = ' '
            def fstr(v, eclr=''):
                vstr = '%5.0f'%v if int(v)==v else ' %6.1f'%v
                if eclr != '':
                    vstr = color(eclr, vstr)
                return vstr
            print('     %10s    %s   %s   %s  %s' % (grip, ''.join(fstr(w, 'red' if len(gfo['added-weights']) != cfgfo['n_sets'] else '') for w in gfo['added-weights']), sentstr, ' '.join(str(gfo[f] if f in gfo else color('purple', '-')) for f in fail_cfg), gfo['note']))

    if hfo is not None:  # add final workout if file doesn't end with empty line
        workouts.append(hfo)
    return workouts

# ----------------------------------------------------------------------------------------
hangfos = []
# for hangfname in glob.glob(args.training_dir + '/[0-9][0-9][0-9][0-9]/hangboard.txt'):
#     year = int(hangfname.split('/')[-2])
for year in args.years:
    hangfname = '%s/%s/hangboard.txt' % (args.training_dir, year)
    hangfos.append(read_hfo(hangfname, year, n_workouts=None))

# ----------------------------------------------------------------------------------------
import matplotlib as mpl
mpl.use('Agg')
mpl.rcParams['svg.fonttype'] = 'none'
import matplotlib.pyplot as plt
import seaborn
seaborn.set_style('ticks')
fsize = 20
mpl.rcParams.update({
    # 'legend.fontweight': 900,
    'legend.fontsize': fsize,
    'axes.titlesize': fsize,
    # 'axes.labelsize': fsize,
    'xtick.labelsize': fsize,
    'ytick.labelsize': fsize,
    'axes.labelsize': fsize
})

# ----------------------------------------------------------------------------------------
def plot_single_grip(gripname):
    # ----------------------------------------------------------------------------------------
    def plot_set(set_key, vbar=True):
        for n_days_list, lw_list, sf_list in zip(mfos['sessions'], mfos[set_key + '-weights'], mfos[set_key + '-send-fractions']):
            # filter out NaN values for plotting
            valid = [(nd, lw, sf) for nd, lw, sf in zip(n_days_list, lw_list, sf_list) if not numpy.isnan(lw)]
            if not valid:
                continue
            valid_nds, valid_lws, valid_sfs = zip(*valid)
            ax.plot(valid_nds, valid_lws, linewidth=3, alpha=0.7, markersize=15, marker='.', color='grey')
            if vbar:
                for nd, lw, sf in zip(valid_nds, valid_lws, valid_sfs):
                    if sf == 0:  # unknown (should change this)
                        ax.text(nd - 0.25, lw + 0.25 * min_weight_increment, '?')
                    else:
                        vw = 8
                        ax.vlines(nd, lw, lw + sf * min_weight_increment, color='green', alpha=0.5, linewidth=vw)
                        ax.vlines(nd, lw + sf * min_weight_increment, lw + min_weight_increment, color='red', alpha=0.75, linewidth=vw)
                    if sf == 1:
                        ax.hlines(lw + sf * min_weight_increment, nd - 0.25, nd + 0.25, color='green', linewidth=3)

    # ----------------------------------------------------------------------------------------
    mfos = {
        # 'n-days' : [],
        'sessions' : [],
        'last-weights' : [],
        'last-but-one-weights' : [],
        'last-send-fractions' : [],
        'last-but-one-send-fractions' : [],
    }
    isession = 0
    xticks, xticklabels = [], []
    for workouts in hangfos:
        for hfo in workouts:
            if gripname not in hfo['grips']:
                continue
            if hfo['session'] == 1:
                if len(mfos['sessions']) > 0:  # add gap between blocks (but not before first block)
                    isession += 2
                for tk in mfos:
                    mfos[tk].append([])

            if len(mfos['sessions']) == 0:
                continue
            mfos['sessions'][-1].append(isession)
            xval = isession
            isession += 1

            if hfo['session'] == 1:
                xticks.append(xval)
                xticklabels.append('%d %s \'%d' % (hfo['date'].day, calendar.month_abbr[hfo['date'].month], hfo['date'].year - 2000))

            gfo = hfo['grips'][gripname]
            # body_weight = hfo.get('weight', 0)
            mfos['last-weights'][-1].append(gfo['added-weights'][-1])  # body_weight +
            mfos['last-but-one-weights'][-1].append(gfo['added-weights'][-2])  # body_weight +

            dbg = False #hfo['session'] == 8
            total_times = [n * float(hfo['cfg']['work_time']) for n in hfo['cfg']['n_reps']]
            if gfo['sent'] == 'yes':
                send_times = total_times
            elif gfo['sent'] == 'unknown' or 'fail-set' not in gfo:
                send_times = [0., 0.]  # TODO this should be unknown rather than 0
            else:
                if dbg:
                    print(gfo['fail-set'], gfo['fail-rep'], gfo['fail-second'])
                if len(gfo['added-weights']) != hfo['cfg']['n_sets']:
                    raise Exception('need to account for grip lines with different number of sets')
                assert gfo['fail-set'] > 0  # doesn't make sense
                send_times = [0., 0.]
                for set_number in range(1, gfo['fail-set'] + 1):  # use 1-indexing, since that's what i implicitly use in the text files
                    if dbg:
                        print(set_number)
                    n_reps = hfo['cfg']['n_reps'][set_number - 1]
                    for rep_number in range(1, n_reps + 1):  # use 1-indexing, since that's what i implicitly use in the text files
                        if set_number == gfo['fail-set'] and rep_number == gfo['fail-rep']:
                            send_times[set_number - 1] += gfo['fail-second']
                            if dbg:
                                print('   %2d  %.0f' % (rep_number, send_times[set_number - 1]))
                            break
                        send_times[set_number - 1] += hfo['cfg']['work_time']
                        if dbg:
                            print('   %2d  %.0f' % (rep_number, send_times[set_number - 1]))
            mfos['last-but-one-send-fractions'][-1].append(send_times[0] / total_times[0])
            mfos['last-send-fractions'][-1].append(send_times[1] / total_times[1])

    dpi = 80
    xpixels, ypixels = 2500, 700
    fig, ax = plt.subplots(figsize=(xpixels / dpi, ypixels / dpi))
    fig.tight_layout()
    plt.gcf().subplots_adjust(bottom=0.27, left=0.05, right=0.95, top=0.92)

    # ----------------------------------------------------------------------------------------
    plot_set('last')
    plot_set('last-but-one')

    plt.xticks(xticks)
    plt.title(gripname, fontweight='bold', fontsize=20)
    ax.grid(axis='y')
    ax.tick_params(labelright=True)
    ax.set_xticklabels(xticklabels, rotation='vertical')
    if not os.path.exists(args.plotdir):
        os.makedirs(args.plotdir)
    plt.savefig('%s/%s.svg' % (args.plotdir, gripname.replace(' ', '-')))


# ----------------------------------------------------------------------------------------
tickday = 1
# max_delta = timedelta(days=7)

for gname in args.plot_grips:
    plot_single_grip(gname)
